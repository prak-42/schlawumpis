
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Die Schlawumpis</title>
  <style>
    /* Seite: komplett weiß */
    html, body {
      height: 100%;
      margin: 0;
      background: #ffffff;
      overflow: hidden; /* Verhindert Scrollen, damit das Rechteck immer im Sichtbereich bleibt */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Container füllt das Sichtfenster */
    .stage {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    /* Das „beinahe weiße“, leicht schräge Rechteck */
    .box {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) rotate(-3deg);
      background: #fcfcfc;              /* fast weiß */
      color: #111;                       /* dunkler Text */
      border-radius: 10px;
      padding: 50px 50px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.01), 0 2px 8px rgba(0,0,0,0.06);
      border: 1px solid rgba(0,0,0,0.06);
      user-select: none;
      cursor: default;                   /* kein Zeiger-Handsymbol */
      transition: transform 120ms ease;  /* kleine, sanfte Bewegungen */
      will-change: transform, left, top;
    }

    /* Leichte Reaktion bei „Annäherung“ (optisch, nicht technisch nötig) */
    .box.near {
      transform: translate(-50%, -50%) rotate(-5deg) scale(1.03);
    }

    /* Textgestaltung */
    .title {
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    .subtitle {
      font-size: 14px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="stage">
    <div id="box" class="box" aria-label="Schlawumpis interaktives Rechteck">
      <p></p>
      <div class="title">hier klicken</div>
      <p></p>
    </div>
  </div>

  <script>
    (function () {
      const stage = document.querySelector('.stage');
      const box = document.getElementById('box');

      // Einstellungen
      const SAFE_MARGIN = 16;           // Abstand zur Fensterkante
      const TRIGGER_DISTANCE = 140;     // Abstand, ab dem die Box „flüchtet“
      const EDGE_PADDING = 80;          // zusätzlicher Puffer, damit die Box nie halb außerhalb landet
      const MOVE_COOLDOWN_MS = 120;     // minimale Zeit zwischen Sprüngen

      let lastMoveTs = 0;

      // Hilfsfunktion: zufällige Position innerhalb des sichtbaren Bereichs
      function randomPositionWithinViewport() {
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        const rect = box.getBoundingClientRect();
        const bw = rect.width;
        const bh = rect.height;

        const minX = SAFE_MARGIN;
        const maxX = Math.max(SAFE_MARGIN, vw - bw - SAFE_MARGIN);
        const minY = SAFE_MARGIN;
        const maxY = Math.max(SAFE_MARGIN, vh - bh - SAFE_MARGIN);

        const x = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
        const y = Math.floor(Math.random() * (maxY - minY + 1)) + minY;

        return { x, y };
      }

      // Versetzt die Box an eine neue Position
      function jumpToNewSpot(preferAwayFrom = null) {
        const now = performance.now();
        if (now - lastMoveTs < MOVE_COOLDOWN_MS) return; // Cooldown

        let { x, y } = randomPositionWithinViewport();

        // Wenn eine Quelle (z.B. Mausposition) angegeben ist, versuche wegzuspringen
        if (preferAwayFrom) {
          const vw = window.innerWidth;
          const vh = window.innerHeight;
          const rect = box.getBoundingClientRect();
          const bw = rect.width;
          const bh = rect.height;

          // Zielquadranten wählen, der am weitesten weg ist
          const toLeft = preferAwayFrom.x < vw / 2;
          const toTop  = preferAwayFrom.y < vh / 2;

          const targetX = toLeft
            ? Math.min(vw - bw - SAFE_MARGIN, preferAwayFrom.x + (vw / 2))
            : Math.max(SAFE_MARGIN, preferAwayFrom.x - (vw / 2));

          const targetY = toTop
            ? Math.min(vh - bh - SAFE_MARGIN, preferAwayFrom.y + (vh / 2))
            : Math.max(SAFE_MARGIN, preferAwayFrom.y - (vh / 2));

          // Mit kleinen Zufallsstreuungen
          x = clamp(targetX + randBetween(-60, 60), SAFE_MARGIN, vw - bw - SAFE_MARGIN);
          y = clamp(targetY + randBetween(-60, 60), SAFE_MARGIN, vh - bh - SAFE_MARGIN);
        }

        box.style.left = `${x}px`;
        box.style.top = `${y}px`;
        // Basis-Transform wiederherstellen (die Startposition nutzt translate(-50%, -50%))
        box.style.transform = `rotate(-3deg)`;
        box.classList.remove('near');

        lastMoveTs = now;
      }

      // Klammerfunktion
      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      // Zufallszahl in Bereich
      function randBetween(min, max) {
        return Math.random() * (max - min) + min;
      }

      // Prüfen, ob Maus nahe an der Box ist
      function isMouseNearBox(mx, my, distance) {
        const r = box.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top + r.height / 2;

        const dx = mx - cx;
        const dy = my - cy;
        const d = Math.sqrt(dx * dx + dy * dy);

        return d < distance;
      }

      // Erste Startposition (zentriert bereits, aber wir setzen eine zufällige)
      jumpToNewSpot();

      // Mausbewegungen beobachten und ggf. flüchten
      window.addEventListener('mousemove', (ev) => {
        const mx = ev.clientX;
        const my = ev.clientY;

        // Optisches Feedback
        if (isMouseNearBox(mx, my, TRIGGER_DISTANCE + 40)) {
          box.classList.add('near');
        } else {
          box.classList.remove('near');
        }

        if (isMouseNearBox(mx, my, TRIGGER_DISTANCE)) {
          jumpToNewSpot({ x: mx, y: my });
        }
      }, { passive: true });

      // Wenn man versucht zu klicken, sofort flüchten
      box.addEventListener('mousedown', (ev) => {
        ev.preventDefault();
        jumpToNewSpot({ x: ev.clientX, y: ev.clientY });
      });

      // Auch bei Touch-Geräten: wegspringen
      window.addEventListener('touchstart', (ev) => {
        const touch = ev.touches && ev.touches[0];
        if (!touch) return;
        jumpToNewSpot({ x: touch.clientX, y: touch.clientY });
      }, { passive: true });

      // Bei Fenstergrößenänderung: sicherstellen, dass die Box im Sichtbereich bleibt
      window.addEventListener('resize', () => {
        const rect = box.getBoundingClientRect();
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        const bw = rect.width;
        const bh = rect.height;

        const x = clamp(rect.left, SAFE_MARGIN, vw - bw - SAFE_MARGIN);
        const y = clamp(rect.top,  SAFE_MARGIN, vh - bh - SAFE_MARGIN);

        box.style.left = `${x}px`;
        box.style.top = `${y}px`;
      });
    })();
  </script>
</body>
</html>
